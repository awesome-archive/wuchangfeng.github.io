---
layout: post
title: 计算机网络常见知识点[转]
date: 2017-03-30 16:17:18 +0800
categories: review
---

### 计算机网络

转自：http://blog.csdn.net/jxh_123/article/details/40316081

#### OSI，TCP/IP，五层协议的体系结构

OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
TCP/IP分层（4层）：网络接口层、网络层、运输层、应用层。
五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。

[OSI参考模型是7层，TCP/IP模型并不包括物理层，其网络接口层下面就是物理网络，所以分成了4层，讲解时一般折中，采用五层协议的方式进行讲解]

*TCP/IP模型和OSI参考模型的对应关系*
网络接口层--对应OSI参考模型的物理层和数据链路层；[主要是物理地址寻址、数据成帧等处理]
网络层--对应OSI参考模型的网络层；[主要对数据包进行路由选择等]
运输层--对应OSI参考模型的运输层；[主要对数据包进行分段并处理拥塞控制和流量控制等]
应用层--对应OSI参考模型的5、6、7层。[主要对数据包进行校验、加密解密、格式转换和解析等]

每一层的作用如下：
**物理层**：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。
**数据链路层**：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
**网络层**：网络层负责对子网间的数据包进行**路由选择**。此外，网络层还可以实现拥塞控制、网际互连等功能。
**传输层**：第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的**差错控制和流量控制**问题。
**会话层**：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
**表示层**：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。
**应用层**：为操作系统或网络应用程序提供访问网络服务的接口。

#### TCP/IP体系的四个层次

TCP/IP体系共有四个层次：应用层（Application Layer）、传输层（Transport Layer）、网络互连层（Internet Layer）和网络接口层（Host-to-Network Layer）

（1）网络接口层（Host-to-Network Layer）=> 接收和发送数据报
**网络接口层主要负责将数据报发送到网络传输介质上以及从网络上接收TCP/IP数据报，相当于OSI参考模型中的物理层和数据链路层。**
在实际中，先后流行的以太网、令牌环网、ATM、帧中继等都可视为其底层协议。它将发送的信息组帧，并通过物理层向选定网络发送，或者从网络上接收物理帧，将去除数据控制信息的IP数据报交给网络互连层。

（2）网络互连层（Internet Layer）=> 数据报封装和路由寻址功能
**网络互连层的主要功能是寻址和对数据报的封装以及重要的路由选择功能。**
这些功能大部分都是由IP协议来完成的，再加上地址解析协议（Address Resolution Protocol，ARP）、因特网控制报文协议（Internet Control Message Protocol，ICMP）等协议从旁协助，所以IP协议是本层众多实体中的核心。下面简单介绍这几个协议。
**网际协议（Internet Protocol，IP）。该协议是一个无连接的协议，主要负责将数据报从源结点转发到目的结点。也就是说，IP协议通过对每个数据报中都有的源地址和目的地址进行分析，然后进行路由选择（即选择一条到达目标的最佳路径），最后再转发到目的地。**需要注意的是：IP协议只是负责对数据进行转发，并不对数据进行检查。也就是说，它不负责数据的可靠性，这样设计的主要目的是提高IP协议传送和转发数据的效率。
地址解析协议（Address Resolution Protocol，ARP）。该协议主要负责将TCP/IP网络中的IP地址解析和转换成计算机的物理地址，以便于物理设备（如网卡）按该地址来接收数据。
反向地址解析协议（Reverse Address Resolution Protocol，RARP）。该协议的作用与ARP的作用相反，它主要负责将设备的物理地址解析和转换成IP地址。
因特网控制报文协议（Internet Control Message Protocol，ICMP）。该协议主要负责发送和传递包含控制信息的数据报，这些控制信息包括哪台计算机出了什么错误、网络路由出现了什么错误等内容。

（3）传输层（Transport Layer）=> 应用进程间的端到端通信
**传输层主要负责在应用进程之间的端到端通信，即从某个应用进程传输到另外一个应用进程。**它与OSI参考模型的传输层功能类似，也对高层屏蔽了底层通信网络的实现细节。
传输层在某一时刻可能要同时为多个不同的应用进程服务，因此为了识别不同的应用进程，传输层在每一个分组中必须增加用于识别信源和信宿的应用程序的标识，同时，每一个分组还要附带校验和，以保证接收端能校验分组的正确性，这样可以将数据报发送到合适的应用进程。这个增加的标识称为端口（port）或者端口号（port ID）。
TCP/IP体系结构的传输层包含两个主要协议，即传输控制协议（Transport Control Protocol，TCP）和用户数据报协议（User Datagram Protocol，UDP）。这两个协议分别应用于有不同要求的应用进程。

（4）应用层（Application Layer）=> 不同协议
应用层是TCP/IP的最高层，它包括了多种高层协议，并且总有新的协议加入。与OSI的应用层类似，它是直接为应用进程服务的一层。即**当不同的应用进程数据通信或者数据交换时，就去调用应用层的不同协议实体，让这些实体去调用TCP或者UDP层服务来进行网络传输。**
与OSI不同，TCP/IP中包含了许多具体的应用层协议。
简单邮件传输协议（Simple Mail Transportation Protocol，SMTP）：该协议主要用于在电子邮件服务器之间传输电子邮件。
域名系统（Domain Name System，DNS）：该协议用于域名与IP地址之间的转换。
超文本传输协议（Hypertext Transportation Protocol，HTTP）：该协议是为因特网上传输和处理超文本或者WWW（World Wide Web）页面而服务的应用层协议。
文件传输协议（File Transportation Protocol，FTP）：该协议是为网络中传输文件进程服务的，所谓传输文件，是指将文件从一台计算机通过网络复制到另一台计算机中。
远程终端协议（Telnet）：该协议是用于远程登录网络主机的一个应用层协议。
简单网络管理协议（Simple Network Management Protocol，SNMP）：该协议用于在控制台与网络设备（如路由器、交换机等）之间交换网络管理信息。

#### TCP与UDP的区别

**TCP协议是一种可靠的、面向连接的协议，保证通信主机之间有可靠的字节流传输，完成流量控制功能，协调收发双方的发送与接收速度，达到正确传输的目的。**
**UDP是一种不可靠、无连接的协议，其特点是协议简单、额外开销小、效率较高，但是不能保证传输是否正确。**
UDP是面向无连接的、不可靠的数据报服务；TCP是面向连接的、可靠的字节流服务。

**TCP对应的协议和UDP对应的协议**
TCP对应的协议：
（1） FTP：文件传输协议，默认使用21端口。
（2） Telnet：一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务，默认使用23端口。
（3） SMTP：简单邮件传送协议，用于发送邮件，默认使用25号端口。
（4） POP3：和SMTP对应，POP3用于接收邮件，默认使用110端口。
（5）HTTP协议：从Web服务器传输超文本到本地浏览器的传送协议，默认使用80端口。

UDP对应的协议：
（1） DNS：域名解析服务，将域名地址转换为IP地址，默认使用53号端口。
（2） SNMP：简单网络管理协议，默认使用161号端口，是用来管理网络设备的。
（3） TFTP(Trival File Transfer Protocal)：简单文件传输协议，默认使用69号端口。

**TCP/IP协议的特点**
1.高可靠性
TCP/IP采用重新确认的方法保证数据的可靠传输，并采用窗口流量控制机制使可靠性得到进一步保证。
*TCP的可靠性如何保证？*
TCP的可靠性是通过顺序编号（SEQ）和确认（ACK）来实现的。
2.安全性
为建立TCP连接，在连接的每一端都必须与该连接的安全性控制达成一致。**IP在它的控制分组头中有若干字段允许有选择地对传输的信息实施保护。**
3.灵活性
TCP/IP要求下层支持该协议，而对上层应用协议不作特殊要求。因此，TCP/IP的使用不受传输介质和网络应用软件的限制。

#### TCP流量控制和拥塞控制

**流量控制：滑动窗口协议**
所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。
TCP滑动窗口：TCP滑动窗口用来暂存两台主机间要传送的数据，有点类似CACHE。
**每个TCP/IP主机有两个滑动窗口：一个用于接收数据，另一个用于发送数据。**
通过每个TCP传输的字段指定顺序号，以获得可靠性。如果一个分段被分解成几个小段，接收主机会知道是否所有小段都已收到。通过发送应答，用以确认别的主机收到了数据。**对于发送的每一个小段，接收主机必须在一个指定的时间返回一个确认。如果发送者未收到确认，数据会被重新发送；如果收到的数据包损坏，接收主机会舍弃它，因为确认未被发送，发送者会重新发送分段。**

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。

**拥塞控制**
拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。

拥塞控制方法
**慢开始( slow-start )和拥塞避免( congestion avoidance )**
发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口的大小。
发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

慢开始算法：每经过一个传输轮次，拥塞窗口 cwnd 就加倍。慢开始的"慢"并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。
为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：
当 cwnd < ssthresh 时，使用上述的慢开始算法。
当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。

拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

**快重传( fast retransmit )和快恢复( fast recovery )**
快重传算法：要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期。

快恢复过程
1.当发送方连续收到三个重复确认，就执行"乘法减小"算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
2.由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（"加法增大"），使拥塞窗口缓慢地线性增大。

#### TCP三次握手和四次挥手的全过程

**连接建立：三次握手**
![](http://ww1.sinaimg.cn/large/b10d1ea5ly1fe4xppj0xej20ob0r40ut.jpg)
首先Client端发送连接请求报文，Server端接收连接请求后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server端发生ACK报文，并分配资源，这样TCP连接就建立了。

**连接断开：四次握手**
假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据，所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请你继续等我的消息"。这个时候Client端就进入**FIN_WAIT**状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后就知道可以关闭连接了，但是它还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入**TIME_WAIT**状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。TCP连接就这样关闭了！

**简单来说，两端都要发送一次FIN，并得到对方的ACK，这样才可以放心地断开连接。**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。**收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据**。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Clien端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步撒手。

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**
这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）。但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此**对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。**
如果client端最后发送的ACK报文丢失了，server端会重发FIN报文，client端收到后继续发ACK报文。
![](http://ww1.sinaimg.cn/large/b10d1ea5ly1fe4xqi0gr0j20f60lcq43.jpg)

#### 在浏览器中输入www.baidu.com 后执行的全部过程

现在假设如果我们在客户端浏览器中输入http://www.baidu.com ，而baidu.com为要访问的服务器，下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：
1、客户端浏览器请求DNS服务器解析域名www.baidu.com 对应的IP地址，然后通过这个IP地址和默认端口80，和服务器建立TCP连接，连接建立之后通过TCP将HTTP会话封装成数据包。
2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口（如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口）然后使用IP层的IP地址查找目的端。
3、在客户端的网络层，通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，主要是通过查找路由表来决定通过哪个路径到达服务器。
4、在客户端的链路层，数据包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

#### HTTP协议包括哪些请求？

HTTP六种请求方法：get，post，update，delete，head，options
GET：请求读取由URL所标志的数据
POST：给服务器添加或者更新数据
PUT：在给定的URL下存储一个文档
DELETE：删除给定的URL所标志的资源
OPTIONS：服务器针对特定资源所支持的HTTP请求方法
HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息

#### HTTP中POST与GET的区别

GET是从服务器上获取数据，POST是向服务器传送数据。
GET是将请求参数加到URL中，POST是将请求数据放在请求体中。
GET传送的数据量较小，不能超过2KB(1024字节?)，POST传送的数据量较大，默认为不受限制。

#### HTTP协议的格式

**HTTP请求包含的内容：1.请求行  2.HTTP头  3.内容**
第一部分请求行写法是固定的，由三部分组成，第一部分是请求方法，第二部分是请求网址，第三部分是HTTP版本。
第二部分包含的头包括：1.请求头(request header) 2.普通头(general header) 3.实体头(entity header)。通常来说，由于GET请求往往不包含内容实体，因此也不会有实体头。
第三部分内容只在POST请求中存在，因为GET请求并不包含任何实体。

**HTTP响应包含的内容：1.状态行  2.HTTP头  3.内容**
第一部分是HTTP版本，第二部分是响应状态码，第三部分是状态码的描述，因此也可以把第二和第三部分看成一个部分。
信息类 (100-199) 响应成功 (200-299) 重定向类 (300-399) 客户端错误类 (400-499) 服务端错误类 (500-599)
第二部分包含的头包括：1.响应头(response header) 2.普通头(general header) 3.实体头(entity header)。
第三部分HTTP响应内容就是HTTP请求所请求的信息。这个信息可以是一个HTML，也可以是一个图片。

#### HTTP头的分类

HTTP头并不是严格要求的，仅仅是一个标签，如果浏览器可以解析就会按照某些标准（比如浏览器自身标准，W3C的标准）去解释这个头，否则不识别的头就会被浏览器无视。对服务器也是同理。
**通用头(General header)**
通用头即可以包含在HTTP请求中，也可以包含在HTTP响应中。通用头的作用是描述HTTP协议本身。比如描述HTTP是否持久连接的Connection头，HTTP发送日期的Date头，描述HTTP所在TCP连接时间的Keep-Alive头，用于缓存控制的Cache-Control头等。
**实体头(Entity header)**
实体头是那些描述HTTP信息的头。既可以出现在HTTP POST方法的请求中，也可以出现在HTTP响应中。比如Content-Type和Content-length都是描述实体的类型和大小的头都属于实体头。其它还有用于描述实体的Content-Language、Content-MD5、Content-Encoding以及控制实体缓存的Expires和Last-Modifies头等。
**请求头(HTTP Request Header)**
请求头是那些由客户端发往服务端以便帮助服务端更好的满足客户端请求的头。请求头只能出现在HTTP请求中。比如告诉服务器只接收某种响应内容的Accept头，发送Cookies的Cookie头，显示请求主机域的HOST头，用于缓存的If-Match、If-Match-Since、If-None-Match头，用于只取HTTP响应信息中部分信息的Range头，用于附属HTML相关请求引用的Referer头等。
**响应头(HTTP Response Header)**
HTTP响应头是那些描述HTTP响应本身的头，这里面并不包含描述HTTP响应中第三部分也就是HTTP信息的头（这部分由实体头负责）。比如说定时刷新的Refresh头，当遇到503错误时自动重试的Retry-After头，显示服务器信息的Server头，设置COOKIE的Set-Cookie头，告诉客户端可以部分请求的Accept-Ranges头等。

#### HTTP缓存

![](http://ww1.sinaimg.cn/large/b10d1ea5ly1fe4xr0ojb1j20gu0db74o.jpg)

HTTP缓存的处理流程：
**1）请求处理**
用户发起一个http请求，缓存获取到URL，根据URL查找是否有匹配的副本，这个副本可能在内存中，也可能在本地磁盘。
**2） 新鲜度检测**
如果缓存中存在所请求资源的副本，则进行新鲜度检测。新鲜度检测举个简单的例子，我们在商店买了一瓶汽水，汽水瓶上肯定会标有过期时间，我们会根据这个过期时间和现在的时间做对比，看看饮料过期了没，如果没过期，我们正常喝就行了，如果已经过期，我们肯定要找商家。其实这就是一个新鲜度检测的过程，HTTP请求的新鲜度检测流程也是这样的，HTTP发起一个请求时，发现缓存中有相应的副本，接着就会检查这个副本有没有过期，如果没有过期，直接使用。如果已经过期，则进行再验证。
**3）服务器再验证**
缓存中的文档过期了并不代表它和服务器上的不一样，所以这个时候就需要问问服务器，过期的这段时间里这个文档到底有没有改变。如果改变了，缓存就会获取一份新的文档副本，然后发送给客户端。如果没有改变，缓存只需要获取新的首部，包括一个新的过期时间，并对缓存中的首部更新。
**4）创建响应并返回**
我们希望缓存看起来就像是来自原始服务器一样，缓存将已缓存的服务器响应首部作为响应首部，发送给客户端。

**保质期的实现**
HTTP中，通过**Cache-Control**首部和**Expires**首部为文档指定了过期时间，通过对过期时间的判断，缓存就可以知道文档是不是在保质期内。Expires首部和Cache-Control:max-age 首部都是来告诉缓存文档有没有过期，为什么需要两个响应首部来做这件简单的事情了？其实这一切都是历史原因，Expires首部是HTTP 1.0中提出来的，因为他使用的是绝对日期，如果服务端和客户端时钟不同步的话（实际上这种情况非常常见），缓存可能就会认为文档已经过了保质期。
HTTP 1.1为了修正这个问题，引入了Cache-Control:max-age 首部，这个首部使用相对时间来控制保质期，让一切变得更加合理。举个例子，我们买了一瓶汽水，如果使用Expires首部来标注保质期，就会这么写：饮料过期时间：2012年12月21日，如果某个2货不知道今天多少号，他还真不知道这饮料过期没，我小时候饮料都这么写。后来，有个挺有名的卖牛奶的，大概就叫蒙牛，他发明了一种标注保质期的方法，他怎么搞了？他这么写：保质期：12个月，行，牛逼了，我牛奶一年前就生产出来的牛奶，今天要发给厂家，发之前，先往包装上印上生产日期（当然是印发货那天），然后告诉你，明年才过期，这多聪明，搞成相对的，毒死你。也许HTTP 1.1借鉴了这个伟大的发明，于是就有了Cache-Control:max-age 首部。

**服务器再验证的实现**
缓存要问问服务器，牛奶已经过期了，到底还能不能喝。我说错了，是文档，不是牛奶。HTTP中，使用两个请求首部来完成这个功能：**If-Modified-Sice**和**If-None-Match**。为啥又要两个首部来完成这个功能了？答案还是因为历史的原因。一开始使用 If-Modified-Sice:<date>首部，date是上一次缓存牛奶时响应中**Last-Modified**首部的值。
客户端拿着这个值，问服务器，这段时间内这个牛奶你有没有修改过？服务器看了看这个牛奶的修改时间，如果没有修改过，会返回一个**304 Not Modified**的响应；如果修改过，把最新的牛奶返回给客户端。后来，人们发现这样有问题，因为就算修改时间变化了，文档也不一定发生改变！于是乎，就有了 If-None-Match:<tag>首部，tag是上一次缓存文档时响应中Etag的值，**Etag是一种唯一标识资源的方式**，就像java中的hashcode，如果hashcode不一样，那么两个对象肯定不一样！

**试探性过期**
如果响应中既没有Cache-Control:max-age 首部又没有Expires首部，缓存可以计算出一个试探性最大使用期。这东西打个比方就是缓存会根据响应的Last-Modified来决定文档靠不靠谱，需不需要再验证，如果Last-Modified中的日期是很早之前，那缓存就认为这文档挺靠谱，近期之内应该不会变化；如果Last-Modified中的日期是最近几天，那缓存可能就认为这文档可能经常改变，不靠谱。当然这么粗略的判断想想就知道不严谨，所以我们一定要设置Expires首部和Cache-Control首部。

#### HTTP和HTTPS的区别

HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议 
它是一个安全通信通道，基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(Secure Socket Layer)进行信息交换，简单来说它是HTTP的安全版。
HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。
HTTP和HTTPS使用的是完全不同的连接方式用的端口也不一样：前者是80，后者是443。
HTTP的连接很简单，是无状态的。HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，一般需要到CA申请证书，免费证书很少，需要交费。

#### HTTPS连接建立

![](http://ww1.sinaimg.cn/large/b10d1ea5ly1fe4xrq3p6rj20i00fkabi.jpg)

**中间人攻击（Man-in-the-Middle Attack = MTMA）**
中间人攻击：中间人获取server发给client的公钥，自己伪造一对公私钥，然后伪造自己让client以为它是server，然后将伪造的公钥发给client，并拦截client发给server的密文，用伪造的私钥即可得到client发出去的内容，最后用真实的公钥对内容进行加密发给server。
解决办法：数字证书，可信任的中间人  证书链

**IP地址的分类** (点分四段十进制)
A类地址以00开头，第一个字节作为网络号，地址范围是：0.0.0.0~127.255.255.255 / 8；
B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255 / 16；
C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255 / 24；
D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址；
E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。

**注：只有A，B，C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。**
=> 0 (A) +128=128 (B) +64=192 (C) +32=224 (D) +16=240 (E) 
=> 增量从 128 到 64 到 32 到 16，每次是上次的一半

**特殊的IP地址**
（1）网络地址
IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号全为0，网络地址代表着整个网络。[IP地址=网络号+主机号，网络地址是主机号全为0的特殊情况]

（2）广播地址
广播地址通常称为直接广播地址，是为了区分受限广播地址。
广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。[广播地址是主机号全为1的特殊情况]

（3）组播地址
D类地址就是组播地址，提供一对多的通信方式。

（4）255.255.255.255
该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。
**注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。**

（5）0.0.0.0
常用于寻找自己的IP地址，例如在RARP，BOOTP和DHCP协议中，若某个未知IP地址的主机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。

（6）回环地址
127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。

（7）A、B、C类私有地址
私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。
A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255
B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255
C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255

**分配IP地址时需要注意什么？**
在分配网络号和主机号时应遵守以下几条准则：
1.网络号不能是127，它被用作回环地址
2.不能将主机号都设置为1，这是广播地址
3.不能将主机号都设置为0，这是网络地址
4.对于本网络来说，主机号应该唯一

**NAT协议、DHCP协议、DNS协议的作用**
**NAT协议**：网络地址转换(NAT，Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
**DHCP协议**：动态主机设置协议（Dynamic Host Configuration Protocol， DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。
**DNS协议**：DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址。

**ARP协议的工作原理**
首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就**向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址**。此ARP请求数据包里包括源主机的IP地址、MAC地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

**常见的路由选择协议，以及它们的区别**
常见的路由选择协议有：RIP协议、OSPF协议。
**RIP协议**：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。
=> 距离向量路由算法
**OSPF协议**：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
=> 最短路径路由算法

**路由设备与相关层**
物理层：中继器（Repeater，也叫放大器），集线器。
数据链路层：网桥，交换机。
网络层：路由器。
网关：网络层以上的设备。

#### socket 链接过程

socket 不仅能保证同一台计算机中的不同进程之间的通信，还能保证不同计算机之间的通信，套接字通信

socket 是对 tcp/ip 协议的封装，socket 本身不是通信协议，而是提供一些调用接口，通过 socket 我们才能使用  tcp/ip。

- http 链接：就是所谓的短连接，即客户端向服务器发送一次请求，服务端响应后会立即断掉
- socket 链接：就是长链接，理论上客户端和服务端一旦建立起链接将不会主动断掉。

#### HTTP连接

  HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

  HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

  1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 
  2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 
  由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

#### SOCKET原理

- 套接字（socket）概念

  套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

  应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

- 建立socket连接 

  建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。

  套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

  服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

  客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

  连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

- SOCKET连接与TCP连接

  创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

- Socket连接与HTTP连接

  由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

  而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

  很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。