---
layout: post
title: 操作系统常见知识点[转]
date: 2017-03-27 16:17:39 +0800
categories: review
---

### 操作系统

转自：http://blog.csdn.net/jxh_123/article/details/40296175

**进程和线程的区别**
**进程是资源拥有的基本单位，线程是独立调度与独立运行的基本单位。**
进程是程序运行时的实例，每个进程都有各自独立的地址空间，一个进程不能访问另一个进程的内存。
线程存在于进程中，同一个进程中的多个线程可以共享进程中的堆空间，但是每个线程都有各自的寄存器和栈。

**进程的状态转换**
就绪状态：CPU时间片用完了由 运行状态 转换为 就绪状态
运行状态：获得CPU调度时由 就绪状态 转换为 运行状态
阻塞状态：运行状态 因等待某个事件发生而进入 阻塞状态，事件发生后由 阻塞状态 转换为 就绪状态

**进程的互斥和同步**
**互斥**：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
**同步**：是指**在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问**。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
简单地说：**同步体现的是一种协作性，互斥体现的是一种排他性**。

**进程间的通信方式**
**管道+命名管道+信号+信号量+消息队列+共享内存+套接字**
（1） 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且**只能在具有亲缘关系的进程间使用**。进程的亲缘关系通常是指父子进程关系。
（2）命名管道 (named pipe) ： 命名管道也是半双工的通信方式，但是**它允许无亲缘关系进程间的通信**。
（3）信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，**主要作为进程间以及同一进程内不同线程之间的同步手段**。
（4） 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
（5）信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
（6）共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的**。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
（7）套接字( socket ) ： 套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同终端及其间的进程通信。

**进程(作业)调度算法**
（1）**先来先服务（FCFS，First-Come-First-Served）**: 此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序来选择作业（或进程）。
（2）**短作业优先（SJF，Shortest Process Next）**：这种调度算法主要用于作业调度，它从作业后备队列中挑选所需运行时间（估计值）最短的作业进入主存运行。
（3）**时间片轮转调度算法（RR，Round-Robin）**：当某个进程执行的时间片用完时，调度程序便停止该进程的执行，并将它送就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片处理机执行时间。
（4）**高响应比优先（HRRN，Highest Response Ratio Next）**: 按照高响应比（（已等待时间＋要求运行时间）/ 要求运行时间）优先的原则，在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行。
（5）**优先权(Priority)调度算法**: 按照进程的优先权大小来调度，使高优先权进程得到优先处理的调度策略称为优先权调度算法。注意：优先数越多，优先权越小。
（6）**多级队列调度算法**：多队列调度是根据作业的性质和类型的不同，将就绪队列再分为若干个子队列，所有的作业（或进程）按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。

**死锁产生的原因，死锁产生的必要条件是什么，如何预防死锁，如何避免死锁，死锁定理？**
死锁产生的**原因**：(1)竞争资源；（2)进程推进顺序不当。
死锁产生的**必要条件**：
（1）**互斥条件**：一个资源一次只能被一个进程所使用，即是排它性使用。
（2）**不剥夺条件**：一个资源仅能被占有它的进程所释放，而不能被别的进程强占。
（3）**请求与保持条件**：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放。
（4）**环路等待条件**：当每类资源只有一个时，在发生死锁时，必然存在一个进程—资源的环形链。

**预防死锁**：破坏四个必要条件之一。
**死锁的避免**：**银行家算法**，该方法允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待，从而避免发生死锁。

银行家算法 [http://www.cnblogs.com/diylab/archive/2008/03/25/1121770.html](http://www.cnblogs.com/diylab/archive/2008/03/25/1121770.html)

**死锁定理**：S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的，该充分条件称为死锁定理。
**死锁的解除**：
（1）方法1：强制性地从系统中撤消一个或多个死锁的进程以断开循环等待链，并收回分配给终止进程的全部资源供剩下的进程使用。
（2）方法2：使用一个有效的挂起和解除机构来挂起一些死锁的进程，其实质是从被挂起的进程那里抢占资源以解除死锁。

**分段式存储管理 和 分页式存储管理的区别？**
**分页式存储管理**：分页存储管理是将一个进程的地址（逻辑地址空间）空间划分成若干个大小相等的区域，称为页，相应地，将内存空间划分成与页相同大小（为了保证页内偏移一致）的若干个物理块，称为块或页框（页架）。在为进程分配内存时，将进程中的若干页分别装入多个不相邻接的块中。
**分段式存储管理**：在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，如有主程序段、子程序段、数据段及堆栈段等，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。
**两者的区别**：
1.页是信息的物理单位，分页是为了实现非连续的分配，以便解决内存的碎片问题，或者说分页是为了系统管理的需要。
2.页的大小固定是由系统确定的，将逻辑地址划分为页号和页内地址是由机器硬件实现的。而段的长度是不固定的，决定与用户的程序长度，通常由编译程序进行编译时根据信息的性质来划分。
3.分页式存储管理的作业地址空间是一维的，分段式的存储管理的作业管理地址空间是二维的。

**页面置换算法有哪些？**
（1）**最佳置换算法（Optimal）**：即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）。
（2）**先进先出置换算法FIFO：**该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。
（3）**最近最久未使用置换算法LRU**（Least Recently Used）：该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。(**注：操作系统不一定是这么实现的，可能是维护一个优先队列来实现的**)
（4）**Clock置换算法**：也叫最近未用算法NRU（Not Recently Used）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。
（5）**最少使用置换算法LFU**：该算法选择最近时期使用最少的页面作为淘汰页。

**生产者消费者问题**
代码实现

**哲学家就餐的问题**
程序员面试金典 P298 代码实现